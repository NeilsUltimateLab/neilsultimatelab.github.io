<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta name="og:site_name" content="NeilsUltimateLab"/><link rel="canonical" href="https://neilsultimatelab.github.io/posts/Understanding%20UIViewController%20Rotation%20when%20embed%20in%20Container%20View%20Controllers"/><meta name="twitter:url" content="https://neilsultimatelab.github.io/posts/Understanding%20UIViewController%20Rotation%20when%20embed%20in%20Container%20View%20Controllers"/><meta name="og:url" content="https://neilsultimatelab.github.io/posts/Understanding%20UIViewController%20Rotation%20when%20embed%20in%20Container%20View%20Controllers"/><title>Understanding UIViewController Rotation ‚çâ | NeilsUltimateLab</title><meta name="twitter:title" content="Understanding UIViewController Rotation ‚çâ | NeilsUltimateLab"/><meta name="og:title" content="Understanding UIViewController Rotation ‚çâ | NeilsUltimateLab"/><meta name="description" content="Understanding `UIViewController` Rotation"/><meta name="twitter:description" content="Understanding `UIViewController` Rotation"/><meta name="og:description" content="Understanding `UIViewController` Rotation"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to NeilsUltimateLab"/></head><body class="item-page"><header><div class="wrapper"><a class="site-name" href="/">NeilsUltimateLab</a></div></header><div class="wrapper"><article><div class="content"><h1>Understanding UIViewController Rotation ‚çâ</h1><h2>Problem</h2><p>To enable the rotation of a single view controller used to display the preview of Images/Videos. It is natural that user will rotate the iPhone and screen changes accordingly, so it feels pleasing. But to achieve this, we need to enable the (almost) all Supported Device orientations.</p><p>Ex: <code>Portrait</code>, <code>LandscapeLeft</code>, <code>LandscapeRight</code>.</p><p>By enabling Supported Device orientations either from <code>Info.plist</code> or via <code>AppDelegate</code>.</p><pre><code><span class="keyword">func</span> application(<span class="keyword">_</span> application: <span class="type">UIApplication</span>, supportedInterfaceOrientationsFor window: <span class="type">UIWindow</span>?) -&gt; <span class="type">UIInterfaceOrientationMask</span> {
  <span class="keyword">return</span> .<span class="dotAccess">all</span>
}
</code></pre><p>By doing this we are allowing other view controllers to also rotate if device orientation changes. But we want only Image/Video Previewing view controller is allowed to Rotate in all orientations.</p><h2>Approach</h2><ul><li>Documentation: <a href="https://developer.apple.com/documentation/uikit/uiviewcontroller">Handling View Rotation</a></li></ul><blockquote><p>A view controller can override the <code>supportedInterfaceOrientations</code> method to limit the list of supported orientations.</p></blockquote><p>By doing we can allow our view controllers to limited orientations like below:</p><h3>ViewController</h3><pre><code><span class="keyword">class</span> ViewController: <span class="type">UIViewController</span> {
  ...
  <span class="keyword">override var</span> shouldAutorotate: <span class="type">Bool</span> {
    <span class="keyword">return false</span>
  }
    
  <span class="keyword">override var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> {
      <span class="keyword">return</span> .<span class="dotAccess">portrait</span>
  }
  ...
}
</code></pre><h3>PreviewingViewController</h3><pre><code><span class="keyword">class</span> PreviewingViewController: <span class="type">UIViewController</span> {
  ...
  <span class="keyword">override var</span> shouldAutorotate: <span class="type">Bool</span> {
    <span class="keyword">return false</span>
  }
    
  <span class="keyword">override var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> {
      <span class="keyword">return</span> .<span class="dotAccess">allButUpsideDown</span>
  }
  ...
}
</code></pre><h2>Results</h2><h3>Configuration 1:</h3><p>The <code>ViewController</code> is now the rootViewController of current <code>window</code> and our <code>PreviewingViewController</code> embedded in <code>UINavigationController</code> is being presented modally covering the entire screen.</p><ul><li>Result: It worked as desired. üòá</li></ul><h3>Configuration 2:</h3><p>The <code>ViewController</code> is embedded in <code>UINavigationController</code>, and <code>PreviewingViewController</code> is the same as <code>Configuration 1</code>.</p><ul><li>Result: It's not working now. <code>ViewController</code> screen is now rotating again as device orientation changes. üôÅ</li></ul><h3>Configuration 3:</h3><p>The <code>ViewController</code> is embedded in <code>UITabBarController</code>, and <code>PreviewingViewController</code> is the same as <code>Configuration 1</code>.</p><ul><li>Result: Same as result as in <code>configuration 2</code>. ‚òπÔ∏è</li></ul><h2>Observations</h2><p>Lets put break-point at <code>supportedInterfaceOrientations</code> on both <code>ViewController</code> and <code>PreviewingViewController</code>.</p><p>In <code>Configuration 1</code>: Break-point being hit every time when new orientation is applied on both view-controllers.</p><p>In <code>Configuration 2</code>: Break-point hit for first time, but not when device rotated on both view-controllers.</p><p>In <code>Configuration 3</code>: same as <code>configuration 2</code>.</p><h2>Revising the documentation üßê</h2><blockquote><p>A view controller can override the <code>supportedInterfaceOrientations</code> method to limit the list of supported orientations.</p></blockquote><blockquote><p>Typically, the system calls this method <code>only</code> on the root view controller of the window or a view controller presented to fill the entire screen;</p></blockquote><p>Yes, this is why <code>Configuration 1</code> is working properly. In this configuration we have our <code>ViewController</code> as the only rootViewController of our window.</p><pre><code><span class="keyword">if let</span> window = (<span class="type">UIApplication</span>.<span class="property">shared</span>.<span class="property">delegate</span> <span class="keyword">as</span>? <span class="type">AppDelegate</span>)?.<span class="property">window</span> {
  <span class="call">print</span>(window.<span class="property">rootViewController</span> <span class="keyword">is</span> <span class="type">ViewController</span>) 
}

<span class="comment">// Prints true.</span>
</code></pre><p>And for the <code>PreviewingViewController</code> is being presented covering entire screen, so its <code>supportedInterfaceOrientations</code> property is also called every time device changes to new orientation.</p><p>So when the device orientation changes we get called for the appropriate <code>UIInterfaceOrientationMask</code></p><p>####So what's the deal for the <code>Configuration 2</code>?</p><p>Yes, now we have <code>UINavigationController</code> as our window's <code>rootViewController</code>.</p><pre><code><span class="keyword">if let</span> window = (<span class="type">UIApplication</span>.<span class="property">shared</span>.<span class="property">delegate</span> <span class="keyword">as</span>? <span class="type">AppDelegate</span>)?.<span class="property">window</span> {
  <span class="call">print</span>(window.<span class="property">rootViewController</span> <span class="keyword">is</span> <span class="type">UINavigationController</span>)
}

<span class="comment">// Prints true.</span>
</code></pre><p>We need to provide appropriate <code>supportedInterfaceOrientations</code> to our UINavigationController controller in order to get notified in <code>ViewController</code></p><p>Lets extend <code>UINavigationController</code>.</p><pre><code><span class="keyword">extension</span> <span class="type">UINavigationController</span> {
  <span class="keyword">open override var</span> shouldAutorotate: <span class="type">Bool</span> {
    <span class="keyword">return true</span>
  }
    
  <span class="keyword">open override var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> {
    <span class="keyword">return</span> topViewController?.<span class="property">supportedInterfaceOrientations</span> ?? .<span class="dotAccess">allButUpsideDown</span>
  }
}
</code></pre><p>Now we have told <code>navigationController</code> to ask its <code>topViewController</code> to return appropriate <code>supportedInterfaceOrientations</code></p><p>As we run, we get hit at break point every-time when device is rotated to new orientation.</p><h4>Now lets see for our <code>Configuration 3</code> too.</h4><pre><code><span class="keyword">extension</span> <span class="type">UITabBarController</span> {
  <span class="keyword">open override var</span> shouldAutorotate: <span class="type">Bool</span> {
      <span class="keyword">return true</span>
  }
    
  <span class="keyword">open override var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> {
    <span class="keyword">return</span> selectedViewController?.<span class="property">supportedInterfaceOrientations</span> ?? .<span class="dotAccess">allButUpsideDown</span>
  }
}
</code></pre><p>As we have told <code>UITabBarController</code> to ask its <code>selectedViewController</code> to return its <code>supportedInterfaceOrientations</code>. As expected, this is working too, Break-point hit when device is rotated to new orientation. Hurray. üòé</p><h3><em>Question</em>:</h3><p><strong>Why we have to extend <code>UINavigationController</code> or <code>UITabBarController</code> (ContainerViewControllers) to do rotation according to its children?</strong></p><p>Further reading the documentation...</p><blockquote><p>child view controllers use the portion of the window providedfor them by their parent view controller andno longer participate directly in decisionsabout what rotations are supported.</p></blockquote><p>This may be the default implementation for container view controllers.</p><h2>Important Note</h2><p>The sole purpose of this gist to understand rotation behaviour of child viewControllers in ContainerViewController like UINavigationController, UITabBarControllers, UISplitViewControllers etc.</p><p>To implement proper rotation behaviour in our viewControllers, we should subclass these <code>ContainerViewController</code> and then override these properties, because extending these <code>UIKit</code> Classes <strong>globally</strong> will cause unexpected behaviour as mensioned in <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html">Customizing Existing Classes</a>.</p><blockquote><p>If the name of a method declared in a category is the same as a method in the original class, or a method in another category on the same class (or even a superclass), the behavior is undefined as to which method implementation is used at runtime. This is less likely to be an issue if you‚Äôre using categories with your own classes, but can cause problems when using categories to add methods to standard Cocoa or Cocoa Touch classes.</p></blockquote><p>Thanks. üòÄ</p></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/uiviewcontroller-rotation">UIViewController Rotation</a></li><li><a href="/tags/article">Article</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>