<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>NeilsUltimateLab</title><description></description><link>https://neilsultimatelab.github.io</link><language>en</language><lastBuildDate>Tue, 2 Jun 2020 09:50:22 +0530</lastBuildDate><pubDate>Tue, 2 Jun 2020 09:50:22 +0530</pubDate><ttl>250</ttl><atom:link href="https://neilsultimatelab.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://neilsultimatelab.github.io/posts/MultipleWindows</guid><title>Multiple Windows</title><description>Multiple Windows in same screen</description><link>https://neilsultimatelab.github.io/posts/MultipleWindows</link><pubDate>Sat, 30 May 2020 19:06:00 +0530</pubDate><content:encoded><![CDATA[<h1>Multiple Windows</h1><p>Multiple windows within the same UIscreen.</p><p>We can create new window like this.</p><pre><code><span class="keyword">let</span> frame = <span class="type">UIScreen</span>.<span class="property">main</span>.<span class="property">bounds</span>
<span class="keyword">let</span> newWindow = <span class="type">UIWindow</span>(frame: <span class="type">CGRect</span>(x: frame.<span class="property">origin</span>.<span class="property">x</span>, y: frame.<span class="property">midY</span>, width: frame.<span class="property">width</span>, height: frame.<span class="property">height</span>/<span class="number">2</span>))
newWindow.<span class="property">isHidden</span> = <span class="keyword">false</span>
</code></pre><p>or if we are on iOS 13 and above and have a <code>UIWindowScene</code>,</p><pre><code><span class="keyword">guard let</span> refWindow = <span class="keyword">self</span>.<span class="property">view</span>.<span class="property">window</span>, <span class="keyword">let</span> scene = refWindow.<span class="property">scene</span> <span class="keyword">else</span> { <span class="keyword">return</span> }
<span class="keyword">let</span> newWindow = <span class="type">UIWindow</span>(windowScene: scene)
newWindow.<span class="property">isHidden</span> = <span class="keyword">false</span>
</code></pre><p>make sure we hold window object strongly at application level.</p><pre><code><span class="keyword">class</span> AppDelegate: <span class="type">UIResponder</span>, <span class="type">UIApplicationDelegate</span> {
    <span class="keyword">var</span> window: <span class="type">UIWindow</span>?
    
    <span class="keyword">var</span> additionalWindows: [<span class="type">UIWindow</span>] = []
    ...
}
</code></pre><p>so the above window creation code will look like this</p><pre><code><span class="keyword">let</span> newWindow = <span class="type">UIWindow</span>(frame: <span class="type">CGRect</span>(x: frame.<span class="property">origin</span>.<span class="property">x</span>, y: frame.<span class="property">midY</span>, width: frame.<span class="property">width</span>, height: frame.<span class="property">height</span>/<span class="number">2</span>))
newWindow.<span class="property">isHidden</span> = <span class="keyword">false

let</span> appDelegate = <span class="type">UIApplication</span>.<span class="property">shared</span>.<span class="property">delegate</span> <span class="keyword">as</span>? <span class="type">AppDelegate</span>
appDelegate?.<span class="property">additionalWindows</span>.<span class="call">append</span>(newWindow)
</code></pre><p>Thats it. We have new window in the screen and we can have as many as we want. üéâ</p><p>To show content in the new window, use <code>rootViewController</code> property of UIWindow.</p><pre><code><span class="keyword">let</span> newRootViewController = <span class="type">UIViewController</span>()
newRootViewController.<span class="property">view</span>.<span class="property">backgroundColor</span> = <span class="type">UIColor</span>.<span class="property">yellow</span>

newWindow.<span class="property">rootViewController</span> = newRootViewController
</code></pre><h2>Animation ü§©</h2><p>Let's add some animation for new window. Since UIWindow is just a <code>UIView</code> subclass we can use <code>UIView.animate</code> methods or <code>UIViewPropertyAnimator</code> for this.</p><p><strong>UIView.animate</strong> example</p><pre><code>newWindow.<span class="property">alpha</span> = <span class="number">0</span>
newWindow.<span class="property">frame</span> = <span class="type">CGRect</span>(x: <span class="type">UIScreen</span>.<span class="property">current</span>.<span class="property">frame</span>.<span class="property">midX</span>, y: <span class="type">UIScreen</span>.<span class="property">current</span>.<span class="property">frame</span>.<span class="property">midY</span>, width: <span class="number">0</span>, height: <span class="number">0</span>)

<span class="type">UIView</span>.<span class="call">animate</span>(duration: <span class="number">0.5</span>, options: .<span class="dotAccess">curveEaseIn</span>, animation: {
    newWindow.<span class="property">frame</span> = <span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">100</span>, width: <span class="number">200</span>, height: <span class="number">200</span>)
    newWindow.<span class="property">alpha</span> = <span class="number">1</span>
} { <span class="keyword">_ in</span>
    <span class="call">print</span>(<span class="string">"Animation completed"</span>)
}
</code></pre><p><strong>UIViewPropertyAnimator</strong> example</p><pre><code><span class="keyword">let</span> timingParameters = <span class="type">UISpringTimingParameters</span>(dampingRatio: <span class="number">0.9</span>)
<span class="keyword">let</span> animator = <span class="type">UIViewPropertyAnimator</span>(duration: <span class="number">0.5</span>, timingParameters: timingParameters)

animation.<span class="call">addAnimations</span> {
    newWindow.<span class="property">frame</span> = <span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">100</span>, width: <span class="number">200</span>, height: <span class="number">200</span>)
    newWindow.<span class="property">alpha</span> = <span class="number">1</span>
}

animation.<span class="dotAccess">addAnimations</span> ({
    newWindow.<span class="property">rootViewController</span>.<span class="property">view</span>.<span class="property">alpha</span> = <span class="number">1</span>
}, delayFactor: <span class="number">0.4</span>)

animation.<span class="call">startAnimation</span>()
</code></pre><h2>Remove window üßπ</h2><p>To remove window, we simply remove it from the <code>additionalWindows</code> from AppDelegate.</p><pre><code><span class="keyword">func</span> close(window: <span class="type">UIWindow</span>, animated: <span class="type">Bool</span> = <span class="keyword">true</span>) {
    <span class="keyword">guard
        let</span> appDelegate = <span class="type">UIApplication</span>.<span class="property">shared</span>.<span class="property">delegate</span> <span class="keyword">as</span>? <span class="type">AppDelegate</span>,
        <span class="keyword">let</span> index = appDelegate.<span class="property">additionalWindows</span>.<span class="call">firstIndex</span>(of: window)
    <span class="keyword">else</span> { <span class="keyword">return</span> }
    
    <span class="keyword">func</span> remove() {
        window.<span class="property">isHidden</span> = <span class="keyword">true</span>
        appDelegate.<span class="property">additionalWindows</span>.<span class="call">remove</span>(at: index)
    }
    
    <span class="keyword">if</span> animated {
        <span class="keyword">let</span> timingParameters = <span class="type">UISpringTimingParameters</span>(dampingRatio: <span class="number">0.9</span>)
        <span class="keyword">let</span> animator = <span class="type">UIViewPropertyAnimator</span>(duration: <span class="number">0.7</span>, timingParameters: timingParameters)
        
        animator.<span class="call">addAnimations</span> {
            window.<span class="property">alpha</span> = <span class="number">0</span>
            window.<span class="property">frame</span> = <span class="type">CGRect</span>(x: window.<span class="property">frame</span>.<span class="property">midX</span>, y: window.<span class="property">frame</span>.<span class="property">midY</span>, width: <span class="number">0</span>, height: <span class="number">0</span>)
        }
        
        animator.<span class="call">addCompletion</span> { <span class="keyword">_ in</span>
            <span class="call">remove</span>()
        }
        
        animator.<span class="call">startAnimation</span>()
    } <span class="keyword">else</span> {
        <span class="call">remove</span>()
    }
}
</code></pre><p>This will release the <code>rootViewController</code> for the closing window. So UIViewController life-cycle is maintained. üòé</p><h2>Notes üìù</h2><p>UIWindow is just a special UIView.</p><ul><li>has <code>rootViewController</code> to show our app's content.</li><li>dispatches events to our views. <a href="https://developer.apple.com/documentation/uikit/uiwindow/1621614-sendevent">sendEvent</a></li><li>handles the keyboard events.</li></ul><p>We don't need to add window as a subview to another window. We just create new instance, provide some size and make it visible.</p><p>To get the keyboard events, we need to make our new window key. <code>newWindow.makeKey()</code>. Only one window can be the key at a time.</p><p><strong>Output</strong></p><img src="https://neilsultimatelab.github.io/Images/multiple-windows.png" alt="Image"/><p>Check out the source code at <a href="https://github.com/NeilsUltimateLab/MultiWindow">github</a>.</p><h2>Use cases üë®üèª‚Äçüíª</h2><ul><li>Commonly we create extra windows for connected screens like TV or Projector. Good examples are Keynote (Presentation Apps) and Games. <a href="https://developer.apple.com/documentation/uikit/uiwindow">UIWindow reference document</a></li></ul><blockquote><p>Most apps need only one window, which displays the app‚Äôs content on the device‚Äôs main screen. Although we can create additional windows on the device‚Äôs main screen, extra windows are commonly used to display content on an external screen, as described in <a href="https://developer.apple.com/documentation/uikit/windows_and_screens/displaying_content_on_a_connected_screen">Displaying Content on a Connected Screen</a>.</p></blockquote><ul><li>One interesting use case come from the iOS developer <a href="https://github.com/insidegui"><em>Gui Rambo</em></a> did for EmojiPickerUI (macOS-style emoji picker for iPadOS). <a href="https://github.com/insidegui/EmojiPickerUI">EmojiPickerUI</a></li></ul><p>Thanks for reading. üôÇ</p>]]></content:encoded></item><item><guid isPermaLink="true">https://neilsultimatelab.github.io/posts/Understanding%20UIViewController%20Rotation%20when%20embed%20in%20Container%20View%20Controllers</guid><title>Understanding UIViewController Rotation ‚çâ</title><description>Understanding `UIViewController` Rotation</description><link>https://neilsultimatelab.github.io/posts/Understanding%20UIViewController%20Rotation%20when%20embed%20in%20Container%20View%20Controllers</link><pubDate>Sat, 30 May 2020 13:06:00 +0530</pubDate><content:encoded><![CDATA[<h1>Understanding UIViewController Rotation ‚çâ</h1><h2>Problem</h2><p>To enable the rotation of a single view controller used to display the preview of Images/Videos. It is natural that user will rotate the iPhone and screen changes accordingly, so it feels pleasing. But to achieve this, we need to enable the (almost) all Supported Device orientations.</p><p>Ex: <code>Portrait</code>, <code>LandscapeLeft</code>, <code>LandscapeRight</code>.</p><p>By enabling Supported Device orientations either from <code>Info.plist</code> or via <code>AppDelegate</code>.</p><pre><code><span class="keyword">func</span> application(<span class="keyword">_</span> application: <span class="type">UIApplication</span>, supportedInterfaceOrientationsFor window: <span class="type">UIWindow</span>?) -&gt; <span class="type">UIInterfaceOrientationMask</span> {
  <span class="keyword">return</span> .<span class="dotAccess">all</span>
}
</code></pre><p>By doing this we are allowing other view controllers to also rotate if device orientation changes. But we want only Image/Video Previewing view controller is allowed to Rotate in all orientations.</p><h2>Approach</h2><ul><li>Documentation: <a href="https://developer.apple.com/documentation/uikit/uiviewcontroller">Handling View Rotation</a></li></ul><blockquote><p>A view controller can override the <code>supportedInterfaceOrientations</code> method to limit the list of supported orientations.</p></blockquote><p>By doing we can allow our view controllers to limited orientations like below:</p><h3>ViewController</h3><pre><code><span class="keyword">class</span> ViewController: <span class="type">UIViewController</span> {
  ...
  <span class="keyword">override var</span> shouldAutorotate: <span class="type">Bool</span> {
    <span class="keyword">return false</span>
  }
    
  <span class="keyword">override var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> {
      <span class="keyword">return</span> .<span class="dotAccess">portrait</span>
  }
  ...
}
</code></pre><h3>PreviewingViewController</h3><pre><code><span class="keyword">class</span> PreviewingViewController: <span class="type">UIViewController</span> {
  ...
  <span class="keyword">override var</span> shouldAutorotate: <span class="type">Bool</span> {
    <span class="keyword">return false</span>
  }
    
  <span class="keyword">override var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> {
      <span class="keyword">return</span> .<span class="dotAccess">allButUpsideDown</span>
  }
  ...
}
</code></pre><h2>Results</h2><h3>Configuration 1:</h3><p>The <code>ViewController</code> is now the rootViewController of current <code>window</code> and our <code>PreviewingViewController</code> embedded in <code>UINavigationController</code> is being presented modally covering the entire screen.</p><ul><li>Result: It worked as desired. üòá</li></ul><h3>Configuration 2:</h3><p>The <code>ViewController</code> is embedded in <code>UINavigationController</code>, and <code>PreviewingViewController</code> is the same as <code>Configuration 1</code>.</p><ul><li>Result: It's not working now. <code>ViewController</code> screen is now rotating again as device orientation changes. üôÅ</li></ul><h3>Configuration 3:</h3><p>The <code>ViewController</code> is embedded in <code>UITabBarController</code>, and <code>PreviewingViewController</code> is the same as <code>Configuration 1</code>.</p><ul><li>Result: Same as result as in <code>configuration 2</code>. ‚òπÔ∏è</li></ul><h2>Observations</h2><p>Lets put break-point at <code>supportedInterfaceOrientations</code> on both <code>ViewController</code> and <code>PreviewingViewController</code>.</p><p>In <code>Configuration 1</code>: Break-point being hit every time when new orientation is applied on both view-controllers.</p><p>In <code>Configuration 2</code>: Break-point hit for first time, but not when device rotated on both view-controllers.</p><p>In <code>Configuration 3</code>: same as <code>configuration 2</code>.</p><h2>Revising the documentation üßê</h2><blockquote><p>A view controller can override the <code>supportedInterfaceOrientations</code> method to limit the list of supported orientations.</p></blockquote><blockquote><p>Typically, the system calls this method <code>only</code> on the root view controller of the window or a view controller presented to fill the entire screen;</p></blockquote><p>Yes, this is why <code>Configuration 1</code> is working properly. In this configuration we have our <code>ViewController</code> as the only rootViewController of our window.</p><pre><code><span class="keyword">if let</span> window = (<span class="type">UIApplication</span>.<span class="property">shared</span>.<span class="property">delegate</span> <span class="keyword">as</span>? <span class="type">AppDelegate</span>)?.<span class="property">window</span> {
  <span class="call">print</span>(window.<span class="property">rootViewController</span> <span class="keyword">is</span> <span class="type">ViewController</span>) 
}

<span class="comment">// Prints true.</span>
</code></pre><p>And for the <code>PreviewingViewController</code> is being presented covering entire screen, so its <code>supportedInterfaceOrientations</code> property is also called every time device changes to new orientation.</p><p>So when the device orientation changes we get called for the appropriate <code>UIInterfaceOrientationMask</code></p><p>####So what's the deal for the <code>Configuration 2</code>?</p><p>Yes, now we have <code>UINavigationController</code> as our window's <code>rootViewController</code>.</p><pre><code><span class="keyword">if let</span> window = (<span class="type">UIApplication</span>.<span class="property">shared</span>.<span class="property">delegate</span> <span class="keyword">as</span>? <span class="type">AppDelegate</span>)?.<span class="property">window</span> {
  <span class="call">print</span>(window.<span class="property">rootViewController</span> <span class="keyword">is</span> <span class="type">UINavigationController</span>)
}

<span class="comment">// Prints true.</span>
</code></pre><p>We need to provide appropriate <code>supportedInterfaceOrientations</code> to our UINavigationController controller in order to get notified in <code>ViewController</code></p><p>Lets extend <code>UINavigationController</code>.</p><pre><code><span class="keyword">extension</span> <span class="type">UINavigationController</span> {
  <span class="keyword">open override var</span> shouldAutorotate: <span class="type">Bool</span> {
    <span class="keyword">return true</span>
  }
    
  <span class="keyword">open override var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> {
    <span class="keyword">return</span> topViewController?.<span class="property">supportedInterfaceOrientations</span> ?? .<span class="dotAccess">allButUpsideDown</span>
  }
}
</code></pre><p>Now we have told <code>navigationController</code> to ask its <code>topViewController</code> to return appropriate <code>supportedInterfaceOrientations</code></p><p>As we run, we get hit at break point every-time when device is rotated to new orientation.</p><h4>Now lets see for our <code>Configuration 3</code> too.</h4><pre><code><span class="keyword">extension</span> <span class="type">UITabBarController</span> {
  <span class="keyword">open override var</span> shouldAutorotate: <span class="type">Bool</span> {
      <span class="keyword">return true</span>
  }
    
  <span class="keyword">open override var</span> supportedInterfaceOrientations: <span class="type">UIInterfaceOrientationMask</span> {
    <span class="keyword">return</span> selectedViewController?.<span class="property">supportedInterfaceOrientations</span> ?? .<span class="dotAccess">allButUpsideDown</span>
  }
}
</code></pre><p>As we have told <code>UITabBarController</code> to ask its <code>selectedViewController</code> to return its <code>supportedInterfaceOrientations</code>. As expected, this is working too, Break-point hit when device is rotated to new orientation. Hurray. üòé</p><h3><em>Question</em>:</h3><p><strong>Why we have to extend <code>UINavigationController</code> or <code>UITabBarController</code> (ContainerViewControllers) to do rotation according to its children?</strong></p><p>Further reading the documentation...</p><blockquote><p>child view controllers use the portion of the window providedfor them by their parent view controller andno longer participate directly in decisionsabout what rotations are supported.</p></blockquote><p>This may be the default implementation for container view controllers.</p><h2>Important Note</h2><p>The sole purpose of this gist to understand rotation behaviour of child viewControllers in ContainerViewController like UINavigationController, UITabBarControllers, UISplitViewControllers etc.</p><p>To implement proper rotation behaviour in our viewControllers, we should subclass these <code>ContainerViewController</code> and then override these properties, because extending these <code>UIKit</code> Classes <strong>globally</strong> will cause unexpected behaviour as mensioned in <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html">Customizing Existing Classes</a>.</p><blockquote><p>If the name of a method declared in a category is the same as a method in the original class, or a method in another category on the same class (or even a superclass), the behavior is undefined as to which method implementation is used at runtime. This is less likely to be an issue if you‚Äôre using categories with your own classes, but can cause problems when using categories to add methods to standard Cocoa or Cocoa Touch classes.</p></blockquote><p>Thanks. üòÄ</p>]]></content:encoded></item></channel></rss>